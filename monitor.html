<!DOCTYPE html>
<html>
<head>
  <title>Geo-Track Monitor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
      max-width: 800px;
      line-height: 1.4;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 10px;
      color: #333;
    }
    h2 {
      font-size: 16px;
      margin-top: 20px;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }
    ul {
      list-style-type: none;
      padding: 0;
    }
    li {
      padding: 8px 0;
      border-bottom: 1px solid #ddd;
    }
    .anomaly {
      color: #d32f2f;
      font-weight: bold;
    }
    .safe {
      color: #388e3c;
    }
    .details {
      font-size: 0.9em;
      color: #666;
      margin-top: 5px;
    }
    .status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 4px;
      background-color: #f5f5f5;
    }
    .loading {
      margin-top: 20px;
      text-align: center;
      color: #666;
    }
    .tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
    }
    .tab {
      padding: 10px 15px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    .tab.active {
      border: 1px solid #ddd;
      border-bottom-color: white;
      margin-bottom: -1px;
      background-color: white;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
  </style>
  <!-- Import TensorFlow.js directly in the HTML -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0/dist/tf.min.js"></script>
</head>
<body>
  <h1>Geo-Track Monitor</h1>
  
  <div class="tabs">
    <div class="tab active" data-tab="monitor">Monitor</div>
    <div class="tab" data-tab="model">Model Status</div>
    <div class="tab" data-tab="blockchain">Blockchain Log</div>
  </div>
  
  <div id="monitor" class="tab-content active">
    <div id="tabsContainer">
      <p class="loading">Loading data...</p>
    </div>
  </div>
  
  <div id="model" class="tab-content">
    <h2>ML Model Status</h2>
    <div id="modelStatus" class="status">
      <p>Model Status: <span id="modelLoaded">Not loaded</span></p>
      <p>Dataset Size: <span id="datasetSize">0</span> entries</p>
      <p>Training Status: <span id="trainingStatus">Not started</span></p>
    </div>
    <button id="trainModel">Train Model</button>
  </div>
  
  <div id="blockchain" class="tab-content">
    <h2>Blockchain Log</h2>
    <div id="blockchainLog">
      <p class="loading">Loading blockchain data...</p>
    </div>
  </div>

  <script>
    // Model Implementation
    const Model = {
      model: null,
      trained: false,
      dataset: [],

      async initialize() {
        try {
          document.getElementById('modelLoaded').textContent = 'Loading...';
          this.dataset = await this.loadDataset();
          document.getElementById('datasetSize').textContent = this.dataset.length;
          document.getElementById('modelLoaded').textContent = 'Ready';
          return true;
        } catch (e) {
          console.error('Model initialization failed:', e);
          document.getElementById('modelLoaded').textContent = 'Failed: ' + e.message;
          return false;
        }
      },

      ipToFeatures(ip) {
        console.log('Converting IP to features:', ip);
        const parts = ip.split(':').map(part => parseInt(part || '0', 16));
        return parts.concat(new Array(8 - parts.length).fill(0)).slice(0, 8);
      },

      async loadDataset() {
        console.log('Loading dataset...');
        try {
          const response = await fetch(chrome.runtime.getURL('dataset.json'));
          if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
          const data = await response.json();
          console.log('Dataset loaded:', data.length, 'entries');
          return data;
        } catch (e) {
          console.error('Failed to load dataset:', e);
          return [];
        }
      },

      async trainModel() {
        if (this.dataset.length === 0) {
          console.error('Empty dataset, skipping training');
          return;
        }
        
        document.getElementById('trainingStatus').textContent = 'Training...';
        
        try {
          const xs = tf.tensor2d(this.dataset.map(d => this.ipToFeatures(d.ip)), [this.dataset.length, 8]);
          const ys = tf.tensor2d(this.dataset.map(d => [d.label]), [this.dataset.length, 1]);
          
          this.model = tf.sequential();
          this.model.add(tf.layers.dense({ units: 16, activation: 'relu', inputShape: [8] }));
          this.model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
          this.model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy' });
          
          await this.model.fit(xs, ys, { 
            epochs: 5,
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                document.getElementById('trainingStatus').textContent = `Training: Epoch ${epoch+1}/5, Loss: ${logs.loss.toFixed(4)}`;
              }
            }
          });
          
          this.trained = true;
          document.getElementById('trainingStatus').textContent = 'Trained successfully';
          
          // Save the model to Chrome storage
          const modelSave = await this.model.save('indexeddb://geo-track-model');
          console.log('Model saved to IndexedDB:', modelSave);
          
          return true;
        } catch (e) {
          console.error('Model training failed:', e);
          document.getElementById('trainingStatus').textContent = 'Training failed: ' + e.message;
          return false;
        }
      },

      async loadSavedModel() {
        try {
          this.model = await tf.loadLayersModel('indexeddb://geo-track-model');
          this.trained = true;
          document.getElementById('trainingStatus').textContent = 'Model loaded from storage';
          return true;
        } catch (e) {
          console.log('No saved model found, need training');
          return false;
        }
      },

      async predictIP(ip) {
        if (!this.trained || !this.model) {
          console.log('Model not trained, returning false for IP:', ip);
          return false;
        }
        try {
          const input = tf.tensor2d([this.ipToFeatures(ip)], [1, 8]);
          const prediction = this.model.predict(input).dataSync()[0];
          console.log('Prediction for IP', ip, ':', prediction);
          return prediction > 0.5;
        } catch (e) {
          console.error('Prediction failed for IP', ip, ':', e);
          return false;
        }
      }
    };

    // Blockchain Implementation
    const Blockchain = {
      chain: [],
      
      async initialize() {
        // Try to load from storage
        const result = await new Promise(resolve => {
          chrome.storage.local.get({ blockchain: [] }, (data) => resolve(data.blockchain));
        });
        
        this.chain = result.length > 0 ? result : [{ 
          index: 0, 
          timestamp: Date.now(), 
          data: "Genesis Block", 
          previousHash: "0", 
          hash: "0" 
        }];
        
        this.renderBlockchain();
        return true;
      },

      async addBlock(newData) {
        try {
          const latest = this.chain[this.chain.length - 1];
          const block = {
            index: this.chain.length,
            timestamp: Date.now(),
            data: newData,
            previousHash: latest.hash
          };
          block.hash = await this.calculateHash(block);
          this.chain.push(block);
          
          // Save to storage
          chrome.storage.local.set({ blockchain: this.chain }, () => {
            console.log('Block added and saved for IP:', newData.ip);
          });
          
          this.renderBlockchain();
          return true;
        } catch (e) {
          console.error('Failed to add block:', e);
          return false;
        }
      },

      async calculateHash(block) {
        const encoder = new TextEncoder();
        const data = encoder.encode(`${block.index}${block.timestamp}${JSON.stringify(block.data)}${block.previousHash}`);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
      },

      isIPBlocked(ip) {
        return this.chain.some(block => 
          typeof block.data === 'object' && block.data.ip === ip
        );
      },
      
      renderBlockchain() {
        const container = document.getElementById('blockchainLog');
        container.innerHTML = '';
        
        if (this.chain.length <= 1) {
          container.innerHTML = '<p>No anomalies logged yet.</p>';
          return;
        }
        
        const list = document.createElement('ul');
        // Skip genesis block
        for (let i = 1; i < this.chain.length; i++) {
          const block = this.chain[i];
          const li = document.createElement('li');
          
          if (typeof block.data === 'object' && block.data.ip) {
            const date = new Date(block.timestamp).toLocaleString();
            li.innerHTML = `
              <strong>Block #${block.index}</strong>
              <div class="details">
                <div>IP: ${block.data.ip}</div>
                <div>Domain: ${block.data.domain || 'Unknown'}</div>
                <div>Time: ${date}</div>
                <div>Hash: ${block.hash.substring(0, 16)}...</div>
              </div>
            `;
          } else {
            li.innerHTML = `<strong>Block #${block.index}</strong> - ${block.data}`;
          }
          
          list.appendChild(li);
        }
        
        container.appendChild(list);
      }
    };

    // Main functionality
    async function loadData() {
      chrome.storage.local.get({ tabGeoData: {} }, (result) => {
        renderData(result.tabGeoData);
      });
    }

    function renderData(data) {
      const container = document.getElementById("tabsContainer");
      container.innerHTML = "";
      
      if (!data || Object.keys(data).length === 0) {
        container.innerHTML = "<p>No data captured yet.</p>";
        return;
      }
      
      for (let tabId in data) {
        const tabData = data[tabId];
        const tabDiv = document.createElement("div");
      
        const heading = document.createElement("h2");
        heading.textContent = tabData.domain || "Unknown Domain";
        tabDiv.appendChild(heading);
      
        const list = document.createElement("ul");
        for (let ip in tabData.results) {
          const info = tabData.results[ip];
          const li = document.createElement("li");
          let text = `${info.city}, ${info.country} (IP: ${info.query})`;
          
          if (info.isAnomaly) {
            li.classList.add('anomaly');
            text += ` - ANOMALY DETECTED`;
            if (info.reroutedTo) {
              text += ` (Rerouted to: ${info.reroutedTo})`;
            }
          } else {
            li.classList.add('safe');
          }
          
          li.innerHTML = text;
          list.appendChild(li);
        }
        tabDiv.appendChild(list);
        container.appendChild(tabDiv);
      }
    }

    // Tab functionality
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding content
        tab.classList.add('active');
        const tabId = tab.getAttribute('data-tab');
        document.getElementById(tabId).classList.add('active');
      });
    });

    // Train model button
    document.getElementById('trainModel').addEventListener('click', async () => {
      await Model.trainModel();
    });

    // Initialize everything
    async function initialize() {
      await Promise.all([
        Model.initialize(),
        Blockchain.initialize()
      ]);
      
      await Model.loadSavedModel();
      loadData();
      setInterval(loadData, 5000);
    }

    // Start the application
    initialize();
  </script>
</body>
</html>